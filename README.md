# CSS Notes

Notes on reading [CSS: The Definitive Guide](http://amzn.eu/6m7B078)

## Chapter 1 - CSS and Documents
- `img`, `input` are _replaced_ elements; most are _nonreplaced_

### Display
- block elements: generate breaks before and after themselves; cannot appear within another element without disrupting it's display; `div`, `p`
- inline els do not generate breaks; `a`, `strong`, `em`
- in HTML, block elements cannot descend from inline elements
- list items are special cases of block elements - they generate the markers

### Stylesheets
- `link` els can have the `rel` attribute as `alternate stylesheet`
- alternate stylesheets should have a `title` attribute too; are grouped by title
- if given a title, a stylesheet is considered "preffered"; once an alt stylesheet is selected, it is not used at all
- alternate stylesheets supported by Gecko-based browsers, like Firefox
- can use media with `import`: `@import url(sheet1.css) projection, screen`
- can link stylesheets with the `Link` header; config is web-server dependend; FF/Opera

### CSS Rule Structure
- `<selector>: { <property>: <value>; }`
- each `<property>: <value>;` tuple constitutes a "declaration"
- in general, CSS is whitespace-insensitive
- comments are removed before parsing; do not count on them for whitespace

### Media Queries
- `media` attr of `link` element
- `media` attr of a `style` element
- `media` descriptor portion of an `@import` statement
- `media` descriptor portion of a @media declaration
- `<link href="a.css" media="print and (color), screen and (color-depth: 8)" rel="stylesheet" />`
- `@import url(print-color.css) print and (color), screen and (color-depth: 8);
- in the two exaples above, if _any_ of the queries evaluates to true, the stylesheet is applied
- can use `and` and `not`, but `not` can only be used in the begginning of a query
- `@import url(foo.css) only all` - not applied by browsers which do not understand MQ; applied otherwise
- the commas separating queries are acting as `or` statements
- all descriptors: https://www.w3.org/Style/CSS/all-descriptors.en.html
- `@supports (display: grid) { ... }` - applies if what is between parens is understood/supported
- `@supports not (display: grid)` - apply rules when something is _not_ understood
- `@supports (shape-outside: circle()) or (-webkit-shape-outside: circle()) { ... }`

## Chapter 7 - Basic Visual Formatting
- each element generates a rectangular box - the _element box_
- each element box has a _content area_ at its center
- each content area is surrounded by optional padding, border, outline and margin
  - in the absence of "surroundings": content area ≡ element box
- background is applied within padding and also to border gaps (e.g. - when dashed)
- margins are transparent - so the bg of _parent_ el. can be seen through them
- by default, border colour is same as the content foreground colour (if text is blue, border is also blue)
- https://www.w3.org/TR/CSS22/box.html#box-dimensions

### Normal Flow
- assuming Western, left-to-right locale, elements "flow" from top to bottom and left to right
- elements can be taken out of the normal flow by floating, positioning or becoming flexbox/grid

### Block Box
- the element box generated by elements like `div`, `p`, headings, etc is a _block_ box
- other elements can be made to generate block boxes with `display: box`
- generates line breaks before and after - each block box takes up a separate line (in normal flow)
- so boxes stack vertically

### Inline Box
- generated by elements like `strong` and `span`
- do not generate line breaks before or after themselves
- other elements can be made to generate inline boxes with `display: inline`

### Inline-block Box
- behaves like an inline block box externally (no line-breaks before/after) and block box internally

### Other
- non-replaced element - content is contained within the document
- replaced element - essentially, is a placeholder - `img`, `input`, etc
- root element - the `html` element

### Containing Block
- is the "layout context" for boxes inside it
- for any given box, the _containing block_ forms at the edge of the content area of the nearest ancestor that generated a block-like box (so, block elements like `div`, but also list items and table-related boxes)
- https://www.w3.org/TR/CSS22/visudet.html#containing-block-details
  - has more info - covers abs. positioned, floated, etc

### Initial Containing Block
- https://www.w3.org/TR/CSS22/visudet.html#containing-block-details
- it's size is the viewport size - not influenced by content

### `display`
- `inline` elements cannot contain `block` elements - that is not valid HTML, but browsers generally still allow it
- `display` can be used to alter how an element is _displayed_, but its inherent nature is not changed - so even if changing the `display` of an `inline` element (like `span`) to `block`, that will only affect how it is displayed; it (the `span`) still remains an `inline` element and should not contain any `block` elements.

### Box Model
- https://www.w3.org/TR/CSS22/box.html
- describes the rectangular boxes that are generated for HTML elements
- from center: content area → padding → border → margin
#### `box-sizing`
- initial: `content-box`
- determine the meaning of `width` and `height` (measure)
- `content-box`: measure refers to the _content box_ - so doesn't include padding, border and margins
- `padding-box`: in addition to the content box, measure includes the padding
- `border-box`: in addition to the content box _and_ padding, measure includes the border
- lemma 1: sum of horizontal components (margin L+R, border L+R, padding L+R, content width) of a block box in normal flow == width of containing block

#### `auto`
- only 3 horizontal components can be `auto`: `width` and the two margin components (L+R)
- if one of them is `auto`, it will be sized according to lemma 1 - so that the sum of the components equals the containers width
- if an "impossible" combination is specified - for example, the sum of the components is less than the containers width - then the right margin will be automatically set to `auto` ([example](http://meyerweb.github.io/csstdg4figs/07-basic-visual-formatting/horizontal-formatting-overriding-right-margin.html))
- if `width` is `auto` and margins are fixed, content area will be stretched to fill available space
- `auto` semantics not affected by the value of `box-sizing`
- if both margins are `auto`, they are both of equal lengths - thus centering the element within the parent
- in normal flow equal-length margins is the correct way of centering elements
- if one of the margins is `auto` and `width` is also `auto`, the margin is reduced to zero with content "stretched" to cover the left-over space ([example](http://meyerweb.github.io/csstdg4figs/07-basic-visual-formatting/horizontal-formatting-auto-width-and-left.html))
- if all three are `auto`, margins are set to 0 with content expanding over all available space
- if `width` is `auto` and a margin is negative, can result in width greater than the container (lemma 1)
- margins are the only box dimensions that can be negative
- if applied to a replaced element, a `width` of `auto` translates to the replaced elements intrinsic width
  - if a length is specified for `width`, the replaced elements height will be scaled in proportion

#### Percentages
- relative to the containers content area width
- lemma 1 still applies
- borders cannot have percentage values; this complicates precise layout when using both percentages and borders
- in general, mixing percentages with length units can cause issues if they don't add up exactly

### Vertical Formatting
- element content determines default height - can be influenced by `width`
- height can be adjusted; if that does not leave enough space for the content, `overflow` comes into play
- by default, `height` defines the height of the _content area_ (much like `width`)
- the sum of vertical components == height of containing block
- `height` and margins can be `auto`
- a margin that is `auto` will be set to 0 (block box, normal flow) - which is why **you can't vertically center**
  - vertical `auto` margins treated differently for positioned elements (not in normal flow)
- vertical padding and borders default to 0 
- percentage height is calculated wrt containing blocks height
- vertical percentage margins are calculated wrt elements **width** (!)
- if containers height is not explicitly declared, percentage heights are `auto`

#### `auto`
- block box in normal flow will be just high enough to enclose inner inline content
- if NFBB has only BB children, height is distance from top BB child's top border edge to bottom BB child's bottom border edge (_margins not included !_)
- if a container has padding, or top/bottom borders, its height encloses margins as well

#### Margin Collapsing
- margins of vertically adjacent BBNF will "collapse"
- if margins "overflow" (due to `auto` height and no padding/borders) then you can have more than 2 margins collapsing
- of all the collapsing margins, the longest one is used
- to prevent one particular elements margins from "overflowing" (and becoming eligible for collapsing) add padding and/or top/bottom border
- adjoining negative margin is _added_ to positive; if multiple, the "most negative" is added to "most positive"
- in [this example](http://meyerweb.github.io/csstdg4figs/07-basic-visual-formatting/negative-margins-collapsing-top-margin-effects.html):
  - if we remove the border and padding from the `div`, if will fully enclose the `p` - but `p`s negative top margin will still "overflow" and cancel out the `div`s top margin; if `p`s margin gets even more negative, will move the whole `div` upwards

## Chapter 12 - Flexible Box Layout
- spec: https://www.w3.org/TR/css-flexbox-1/
- box model: https://drafts.csswg.org/css-flexbox-1/#box-model
- can alter order; but screen readers still read in source order (for now, at least)
- flex containers can be block or inline
- `display: flex` == `display: flex block`
- `display: flex inline` == `display: inline-flex`
- **only immediate children are _flexed_**
- flexbox is intended for single-dimensional content distribution, not grid-like layouts
- by default, non-fitting items don't wrap; they shrink if allowed by `flex` prop, and/or overflow
- `flex-wrap` - controls whether the flex container is limited to being single-line
- `flex-flow` - combines `flex-direction` and `flex-wrap`

### Distribution Inside the Flex Container
- `justify-content`: _items_ in a flex line, along **main** axis; `flex-start/end`, `space-between/around/evenly`, `center`
- [`align-items`](https://drafts.csswg.org/css-flexbox-1/#align-items-property): _items_ along the **cross** axis of **each flex line**; `stretch`, `flex-start/end`, `center`, `baseline`
- [`align-self`](https://drafts.csswg.org/css-flexbox-1/#align-items-property): override `alight-items` for particular items; values available are the same (`stretch`, ...) but default is `auto`
- [`align-content`](https://drafts.csswg.org/css-flexbox-1/#align-content-property): _lines_ along the **cross** axis of the flex container; **`stretch`**, `start`, `center`, `space-between`, `space-around`
- if a flex item has an explicit dimension set, it is not "stretchable"
- the stretched dimension includes the margin
- the "stretch budget" is distributed equally among the items, regardless of their relative sizes
- text nodes get wrapped in an anonymous flex item
- whitespace is removed
- `float` is ignored
- `position: absolute` - takes the element out of flow
- `min-width` is `auto` for flex items; for most other elements, it is `0`

### Flexing
- `flex`: shorthand for `flex-grow`, `flex-shrink` and `flex-basis`; default: `0 1 auto`
- flex items will not shrink to less than border, padding and margins combined
- shorthand is strongly recommended over sub-properties
- `width` or `height` is ignored - whichever corresponds to the main axis; even with `!important`
- percentages are valid values only for `flex-basis` and are relative to element's parent's inner main-axis size
- **shrinking is also proportional to the width**; growing is not
- when both `width` and `flex-basis`, `flex-basis` wins in determining width
- `flex basis` - when percent, it is relative to flex container's size
